# 함수

- 함수는 왜 사용하나? `코드 재사용` `유지보수 편리` `가독성 향상`
- 함수는 객체(일급객체)
- 함수 이름은 생략 가능(선언문에서는 생략불가)

</br>

### 함수 호출과 동작

- 함수 이름은 함수 바디 내에서만 참조할 수 있음.
- JS 엔진은 함수 선언문을 해석해 함수 객체를 생성.
    - `암묵적으로 함수 이름으로 함수 식별자를 생성`하고 함수 객체를 할당한다.
- 결론적으로 자바스크립트 엔진은 `선언문을 표현식으로 바꿔서` 함수 객체를 생성

- **함수 호이스팅**
  >- 선언문으로 정의한 함수는 이전에 호출 가능
  >- 표현식으로 정의한 함수는 이전에 호출이 불가
  >- 왜? 함수 생성 시점이 달라지기 때문이다.
  >- 표현식으로 함수를 정의하면 `함수 객체`로 초기화되는 함수 호이스팅이 아니라, 변수 호이스팅으로 동작, 즉 `undefined`로 초기화.


</br></br>

## 함수 정의

1. 함수 선언문
    
    ```jsx
    function hi(){
    	console.log("hi");
    }
    ```
    
2. 함수 표현식
    
    ```jsx
    const greetFn = function (){
    	console.log("hi");
    }
    ```
    
3. 화살표 함수
    
    ```jsx
    const greetFn = () => {
    	console.log("hi");
    }
    
    const add = (x,y) => x+y;
    ```
    
4. Function 생성자 함수
    
    ```jsx
    const add = new Function('x','y','return x+ y');
    ```
    
</br>

## `call by value` vs. `call by reference`

- `값에 의한 호출`: 파라미터에 원시값을 전달
    - 값 자체가 복사되어 파라미터에 전달
    - 원본 훼손되지 않는다. (`side effect` 없음 = 순수 함수 속성)
- `참조에 의한 호출`: 파라미터에 객체 전달
    - 참조값이 복사되어 파라미터로 전달된다.
    - 원본 훼손 (`side effect` 발생)

→ 깊은 복사(`deep copy`)로 사본 참조값을 전달


</br>


## 함수의 다양한 형태

- 즉시실행함수(`IIFE`, immediately invoked func. expression)
    - 익명이 일반적
    
    ```jsx
    (function () {
    	// 함수 동작
    })
    ```
    
- 재귀함수(recursive func.)
- 중첩함수(nested func.)
- 콜백 함수(call back함수): 함수의 파라미터로 다른 함수 내부에 전달되는 함수이다. 헬퍼함수 역할을 한다.
- 고차(Higher-order) 함수(`HOF`): 파라미터로 콜백을 전달받은 함수
- 순수함수
    - side-effect 없음. 동일한 인수에 대해서 동일한 값을 리턴한다.
    - 어떠한 외부상태에도 의존하지 않고 parameter를 통해 전달된 argument에 의존해서 값을 리턴한다.

>외부 상태? 전역변수, 서버 데이터, 파일, 콘솔, 돔 등이 있다.

- 비순수 함수: side-effect가 있음

</br></br>

# 일급 객체

자바스크립트 함수는 아래 조건을 모두 만족하는 일급 객체이다.

- 런타임에 생성이 가능하다(무명의 리터럴 생성)
- 변수나 자료구조에 저장할 수 있다.
- 함수의 파라미터에 전달할 수 있다.
- 함수의 리턴값으로 사용 가능하다

</br>

### 일반 객체와의 차이?

- 호출가능하다(`callable`)
- 함수 객체의 프로퍼티를 갖는다.

</br></br>

## 함수 객체의 프로퍼티

### arguments 프로퍼티

- 함수 호출 시 전달된 인수(argument)정보를 담은 순회가능한(iterable) 유사배열객체
- 함수 내부 로컬 변수로 사용
- 초과 전달된 인수도 전부 보관.
- `length` 프로퍼티 지원.

</br>

### length 프로퍼티

- 함수 정의 시 선언한 파라미터의 개수
- arguments.length와 다르다

</br>

### name 프로퍼티

- 함수 이름
- 익명 함수의 경우
    - ES5 → `‘ ‘`
    - ES6 → 함수 객체를 가리키는 식별자

</br>

### `__proto__`접근자 프로퍼티

- 모든 객체는 `[[ Prototype ]]` 내부 슬롯을 갖는다. 얘는 `Prototype` 객체를 가리킴
- `__proto__`이 친구는 `[[ Prototype ]]` 내부 슬롯이 가리키는 프로토타입 객체에 접근할 수 있는 접근자 프로퍼티이다.

>`obj.__proto__`를 실행하면 obj가 상속받은 프로토타입을 확인할 수 있다. 근데 `Object.getPrototypeOf(obj);` 사용을 더 지향한다.

### prototype 프로퍼티

- `constructor`만 소유하는 프로퍼티이다.
- 일반 객체, non-constructor에는 이 프로퍼티가 없다.


</br></br>

# ES6 함수

🚧 작성 중 🚧

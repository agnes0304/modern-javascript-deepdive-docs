# 소스 코드

실행 컨텍스트를 생성하는 소스 코드의 종류는 4가지
</br>소스 코드의 타입에 따라 실행 컨텍스트를 생성하는 과정과 관리 내용이 다름

- 전역 코드
    - 전역 스코프 생성 → `var`로 선언된 전역변수, 전역함수를 전역객체의 프로퍼티로 바인딩, 참조 위해 전역객체와 연결 → 전역 실행 컨텍스트 생성

- 함수 코드
    - 지역 스코프 생성 → 지역변수, 매개변수, arguments 객체 관리, 전역스코프에서 시작하는 스코프 체인으로 연결 → 함수 실행 컨텍스트 형성

- `eval` 코드
    - 빌트인 전역함수 eval 함수에 인수로 전달되어 실행되는 소스 코드    
    - `strict mode`에서 독자 스코프 생성 → `eval` 실행 컨텍스트 생성

- 모듈 코드
    - 모듈 스코프 생성 → 모듈 실행 컨텍스트 생성

아래에서는 전역과 함수 코드만을 가정하고 살펴볼 예정

</br>

## 소스코드 평가, 실행

### 평가
- 변수, 함수 선언문 먼저 실행
- 각 식별자를 키로하여 실행컨텍스트가 관리하는 스코프(렉시컬 환경의 환경 레코드)에 등록

### 실행 = 런타임 시작
- 선언문 제외 소스코드가 순차 실행

### 예시
렉시컬 환경의 설명이 꽤나 복잡하다. 그러나 큰 틀은 아래와 다르지 않다.
> 전역코드 평가 - 전역코드 실행 - 함수 호출 - 함수코드 평가 - 함수코드 실행 - 함수 호출 종료 - 함수 호출 이전으로 - 전역코드 실행


</br></br>

# 실행 컨텍스트

소스 코드를 실행하는 데 필요한 환경을 제공하고 코드의 실행결과를 실제로 관리하는 영역

- **렉시컬 환경**: 식별자(변수, 함수, 클래스 등)을 등록하고 관리하는 스코프
- **실행 컨텍스트 스택**(콜스택): 코드실행 순서 관리 내부 메커니즘

</br>

## 실행 컨텍스트 스택(콜 스택)
기본개념은 스택이라는 자료 구조로 실행 컨텍스트를 `push/pop`한다.
</br>아래의 예제를 가지고 접근해보자.

```jsx
const a = 1;

function first () {
  const b = 2;
	
  function second(){
    const c = 3; 
    console.log(a+b+c);
  }
  second();
}

first();
```


1. 전역 코드 평가
   - 전역 변수 `a`와 전역 함수 `first`는 전역 실행 컨텍스트에 등록
   - 콜스택에 `push`

2. 전역 코드 실행
   - `a`에 1이 할당되고 `first`가 호출

3. `first` 함수 코드 평가
   - 로컬 변수 `b`와 `second`가 `first` 함수 실행 컨텍스트에 등록
   - 콜스택에 `push`

4. `first` 함수 실행
   - `b`에 2가 할당되고 `second`가 호출

5. `second` 함수 코드 평가
   - 로컬 변수 `c`가 등록
   - 콜스택에 `push`

6. `second` 함수 코드 실행
   - `console.log` 호출(콜스택에 `push/pop)`

7. `first` 함수 코드 종료 = 콜스택에서 `second` 함수 실행 컨텍스트 `pop`
8. 전역 코드로 복귀 = 콜스택에서 `first` 함수 실행 컨텍스트 `pop`
9. 전역 실행 컨텍스트, 콜스택에서 `pop`

</br>

>자 여기까지는
</br>😲실행 컨텍스트 스택이 스택 구조구나! 
</br>😲평가하고 스택에 push되고 실행하고 종료되면 pop되는구나!
</br>까지만 확실히 알면 됐다. 

**스택 흐름을 갖고 이제 렉시컬 환경에 대한 이해를 붙여보도록 하자.**

</br>

## 렉시컬 환경(Lexical environment)

- 키-값 객체 형태의 스코프를 생성
- 키는 식별자로 하여 바인딩된 값을 관리
- 실행 컨텍스트는 lexical env와 variable env 컴포넌트로 구성
    - 생성 초기, 각각은 동일한 렉시컬 env를 참조 (→ 렉시컬 환경으로 통일해서 설명)
    - lexical env는 env record(환경 레코드), outer lexical env reference(외부 렉시컬 환경에 대한 참조) 컴포넌트로 구성
        - outer lexical env reference은 상위 스코프를 가리킴, 해당 실행 컨텍스트를 생성한 소스코드를 포함하는 상위 코드의 렉시컬 환경.
    

위에서 활용한 예제를 가지고 실행 컨텍스트의 변화를 살펴보자.

```jsx
const a = 1;
var x = 10;

function first () {
  const b = 2;
  var y = 20;
	
  function second(){
    const c = 3; 
    var z = 30;
    console.log(a+b+c+x+y+z);
  }
  second();
}

first();
```

1. 전역 객체 생성
    - 전역코드 평가 이전에 생성
    - 표준 빌트인, 호스트 객체

2. 전역 코드 평가
   - 전역 실행 컨텍스트 생성 → 콜스택에 `push` = 실행중인 실행 컨텍스트
   - 전역 렉시컬 환경 생성 → 전역 실행 컨텍스트에 바인딩
     
        >1. 전역 환경 레코드 생성 
           </br>- 객체 환경 레코드 생성 → `var` 키워드 전역 변수 `x=10`, 함수 선언문 전역함수`first`, 빌트인 전역 프로퍼티/함수/객체
           </br>- 선언적 환경 레코드 생성 → `let, const` 키워드 전역 변수 `a`
               </br>*let, const로 생성한 전역변수는 전역 객체의 프로퍼티가 되지 않고 개념적인 블록 내에 존재한다고 함. 
        >2. this 바인딩 → 내부 슬롯 `[[GlobalThisValue]]`에 전역 객체 바인딩
        >3. 외부 렉시컬 환경에 대한 참조 결정 → 전역이니까 `null`(종점)

3. 전역 코드 실행
   - 할당을 위해 식별자를 검색한다. *어디서? 실행중인 실행 컨텍스트에서(식별자 결정)
   - 렉시컬 환경에서 검색 → 없으면 `외부 렉시컬 환경에 대한 참조`가 가리키는 렉시컬 환경으로 가서 검색

    	>1. 변수가 할당된다. (`let, const` 선언한 전역 변수에 이제 할당된다) `a = 1`
    	>2. `first`함수가 호출된다.

4. `first` 함수 코드 평가
   - 함수 실행 컨텍스트 생성 → 콜스택에 `push` = 실행 중인 실행 컨텍스트
   - 함수 렉시컬 환경 생성
     
        >1. 함수 환경 레코드 생성 → 매개변수, arguments 객체, 지역 변수`y=20`,`b`, 중첩함수 `second` 등록
        >2. this 바인딩 → `[[ThisValue]]`에  함수 호출 방식에 따라 전역 객체 바인딩(왜? 일반함수로 호출됨)
        >3. 외부 렉시컬 환경에 대한 참조 결정 → 해당 함수 정의가 평가된 시점에 실행중인 실행 컨텍스트의 렉시컬 환경, 즉 전역 렉시컬 환경을 가리킨다.

5. `first`함수 실행
   - 할당 `b=2`,`second`함수 실행

6. `second`함수 코드 평가
   - 함수 실행 컨텍스트 생성 → 콜스택에 `push` = 실행중인 실행 컨텍스트
   - 함수 렉시컬 환경 생성
   
        >1. 함수 환경 레코드 생성 → 매개변수, arguments 객체, 지역 변수`z=30`,`c`등록
        >2. this 바인딩 → `[[ThisValue]]`에  함수 호출 방식에 따라 전역객체 바인딩(왜? 일반함수로 호출됨)
        >3. 외부 렉시컬 환경에 대한 참조 결정 → 해당 함수 정의가 평가된 시점에 실행중인 실행 컨텍스트의 렉시컬 환경, 즉 `first`함수 렉시컬 환경을 가리킨다.

위의 과정을 이미지로 나타내면 아래와 같다.

![실행 컨텍스트](https://github.com/agnes0304/modern-javascript-deepdive-docs/assets/86249667/4fa71532-da9b-41e7-acc9-d6472f15b2af)

7. `second` 함수 실행
   - 할당 `c=3`
   - `console.log(a+b+c+x+y+z+);` 실행 (사실 얘도 콜스택 push/pop과정 있다)

     	>1. console 식별자 전역에서 검색(BindingObject 통해)
        >2. log 메서드 검색: console의 프로토타입 체인으로 검색
        >3. a+b+c+x+y+z 평가를 위해 렉시컬 레코드에서 식별자 검색

	해당 과정을 이미지로 나타내면 아래와 같다.
	![검색](https://github.com/agnes0304/modern-javascript-deepdive-docs/assets/86249667/5096f90b-9742-498d-8848-95bdd29e8040)

   - `second` 함수 실행 컨텍스트 `pop`
  
7. `first` 함수 종료, 실행 컨텍스트 `pop`
8. 전역 코드 실행 종료, 실행 컨텍스트 `pop`

    

</br>



## 블록레벨 스코프

`let`, `const`는 블록레벨 스코프도 인정한다고 했지. 
만약 코드 블록 내에 let, const로 변수가 선언되면 블록레벨 스코프를 생성하고 환경 레코드의 선언적 환경 레코드에 저장한 다음 렉시컬 환경으로 하여금 블록 레벨 렉시컬 환경을 가리키게 해야 한다. 

